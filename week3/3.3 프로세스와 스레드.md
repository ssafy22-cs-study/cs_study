# 3.3 프로세스와 스레드

날짜: 2023년 8월 31일
발표자: Jaehui Boo
태그: 운영체제
분류: 발표자료

*프로세스: 컴퓨터에서 실행되어야 하는 ‘작업’. 프로그램의 인스턴스화된 것. 

*스레드: 프로세스내의 작업 흐름 

- **3.3.1 프로세스와 컴파일 과정**
    
    ![프로그램의 컴파일 과정](3%203%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%206e0a2393a34b43c0a2092a7b9bb6307a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-08-27_11.32.51.png)
    
    프로그램의 컴파일 과정
    
    *전처리: 소스코드의 주석을 제거하고, #include등의 헤더 파일을 처리.
    
    *컴파일러: 오류 처리, 코드 최적화 작업 ⇒ ‘어셈블리어’로 변환
    
    *어셈블러: 어셈블리어 → 목적 코드로 변환( ex) .c ⇒ .o)
    
    *링커: 라이브러리 함수 또는 다른 파일들과 목적 코드를 병합하여 실행파일(.exe) 생성 
    
- **3.3.2 프로세스의 상태**
    
    ![스크린샷 2023-08-27 11.41.03.png](3%203%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%206e0a2393a34b43c0a2092a7b9bb6307a/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2023-08-27_11.41.03.png)
    
    ![Untitled](3%203%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%206e0a2393a34b43c0a2092a7b9bb6307a/Untitled.png)
    
- **3.3.3 프로세스의 메모리 구조**
    
    > **동적 영역**: 런타임 단계에서 메모리 할당
    > 
    - 스택: 위 주소부터 할당. 지역변수, 매개변수, 실행되는 함수에 대해 증/감하는 영역.
    - 힙: 아래 주소부터 할당. 동적으로 할당되는 변수. malloc(), free(), vector 등.
    
    > **정적 영역**: 컴파일 단계에서 메모리 할당
    > 
    - 데이터 영역 : 전역 변수, static, const - BSS segment(0으로 초기화 or 초기화X)
                                                               - Data segment(0이 아닌 값으로 초기화)
    - 코드 영역: 프로그램의 코드 영역
- **3.3.4 PCB(Process Control Block)**
    
    <aside>
    💡 **PCB**: OS에서 한 프로세스에 대한 메타데이터를 저장한 ‘데이터’ 의미. (=프로세스 제어 블록)
    
    </aside>
    
    *메타데이터: 데이터에 대한 구조화된 데이터 (효율↑). 중요 정보이기 때문에 커널 스택의 앞에서 관리.
    
    **[구조]**
    
    - 프로세스 스케줄링 상태, 프로세스 ID, 프로세스 권한, 프로세스 카운터
    - CPU 레지스터, CPU스케줄링 정보
    - I/O상태 정보, 계정 정보
    
    <aside>
    💡 **컨텍스트 스위칭**: PCB 교환하는 과정. *할당시간 종료 / 인터럽트에 의해 발생. =프로세스 변경
    
    </aside>
    
    *위 개념은 싱글코어(1컴퓨터-1프로세스 실행) 기준.   *현대 컴퓨터는 멀티코어(1컴퓨터-여러 프로세스)
    
    - 컨텍스트 스위칭에 드는 비용
        
        1) 유휴 시간: 프로세스 ‘대기’상태의 시간. (내 PCB가 할당되길 기다리는중~)
        
        2) 캐시미스: 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생기므로 캐시클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생한다.
        
    - 컨텍스트 스위칭은 **스레드에서도** 일어난다. 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 비용↓, 시간↓ 👍
- **3.3.5 멀티프로세싱**
    
    <aside>
    💡 **멀티 프로세싱**: 여러 개의 프로세스를 동시에 수행하는 것.      *신뢰성
    
    </aside>
    
    **[IPC] (Inter Process Communication)**
    
    : 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘   ex) 서버-클라이언트
    
    **<방식>**
    
    - **‘공유 메모리’**: 하나의 큰 메모리 공간이라 생각. 여러 프로세스가 통신/공유.
    - ‘**소켓’**: 동일한 컴퓨터 내의 다른 프로세스 or 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터. (TCP, UDP)
    - **‘익명파이프’**: 부모-자식 프로세스 간에서만 사용하는 파이프, 쓰기전용-pipe→읽기전용
    - **‘명명파이프’**: 하나의 파이프 서버가 여러 파이프 클라이언트와 통신할 수 있도록.
    - ‘**메시지 큐’**: 메시지를 큐 데이터의 구조로 관리하는 것. 사용방법이 직관적이고 간단하여 사용성이 높다.
- **3.3.6 스레드와 멀티스레딩**
    
    <aside>
    💡 **스레드**: 프로세스의 실행 가능한 가장 작은 단위
    
    </aside>
    
    - 멀피스레드 기반 프로세스에서 스레드끼리는 코드, 데이터, 힙을 공유함. 
    *한 스레드에 오류 ⇒ 다른 스레드에도 영향..
    - **멀티스레딩**: 하나의 프로세스 ⇒ 여러 개의 스레드로 처리하는 기법. 즉, 일 분배~
- **3.3.7 공유자원과 임계영역**
    - **‘경쟁 상태’**: 공유자원을 두 개 이상의 프로세스가 동시 읽거나 쓰는 상황. 
    *접근 타이밍과 순서 등 ⇒ 결괏값에 영향.. 막 타이밍이 꼬여서 이상한 결과 출력..
    - **‘임계영역’**: 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
    
    > **해결방안**) 뮤텍스, 세마포어, 모니터     **조건**) 상호 배제, 한정 대기, 융통성
    > 
    - ‘**상호배제’**: =잠금. 임계영역에 한 프로세스가 들어가면 다른 프로세스는 접근X!!
    - ‘**한정대기’**: 특정 프로세스가 영원히 임계영역에 들어가지 못하게 하면 X!!
    - **‘융통성’**: 한 프로세스가 다른 프로세스를 방해하면 X!!
    
    1) 뮤텍스(mutex) : lock / unlock하는 객체. **“잠금 메커니즘”**
    
    2) 세마포어(semaphore) : 일반화된 뮤텍스. wait(기다려~)/signal(다음~)를 이용하여 공유 자원 접근 처리.  *조건 변수가 따로 X.   **“신호 메커니즘”**
    
    |  | 바이너리 세마포어 | 카운팅 세마포어 |
    | --- | --- | --- |
    | 사용값 | 0, 1 | 여러 개의 값  |
    | 사용성 | ex) 음악 듣다가 전화오면 → 통화 | 여러 자원에 대한 접근 제어에 사용 |
    
    3) 모니터 : 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유자원을 숨기고 해당 접근에 대해 인터페이스만 제공. 즉, 공유자원↔ 모니터 큐 ←접근! 
    
    ⇒ 모니터가 세마포어보다 구현에 용이. 
    모니터는 상호 배제가 ‘자동’ BUT 세마포어는 상호 배제를 명시적으로 구현해야 함. 
    
- **3.3.8 교착 상태**
    
    <aside>
    💡 **교착 상태(deadlock)**:  두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태.
    
    </aside>
    
    **[원인]**
    
    - 상호배제 - 한 프로세스가 독점.
    - 점유 대기 - 한 프로세스가 점유한 것을 다른 프로세스가 요구.
    - 비선점: 다른 프로세스의 자원을 강제로 가져올 수 없다.
    - 환형 대기: 서로가 서로의 자원을 요구. 즉, A: 너꺼 줘!! B: 너먼저. A:너먼저. …
    
    **[해결방안]**
    
    1) 위 조건이 성립하지 않도록 설계.
    
    2) 은행원 알고리즘 사용하여 교착 상태 가능성이 없을 때만 자원 할당.
    
    <aside>
    <img src="https://www.notion.so/icons/checkmark-line_gray.svg" alt="https://www.notion.so/icons/checkmark-line_gray.svg" width="40px" /> **은행원 알고리즘**: 총 자원의 양과 현재 할당한 자원의 양 기준으로 불안정→안정
    
    </aside>
    
    3) 교착 상태 발생 시, 사이클 존재 여부 확인.
    
    4) ‘응답없음’ 뜨는 창 ⇒ 사용자가 직접 강제 종료.